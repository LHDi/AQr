{"version":3,"sources":["fragments/Camera/index.js","fragments/Display/index.js","App.js","serviceWorker.js","index.js"],"names":["resList","getConstraints","height","width","filter","res","min","max","map","label","exact","cameraReducer","cameraList","selected","type","id","list","resolution","selectedRes","resolutions","streamReducer","stream","permitted","newstream","Camera","children","useReducer","dispatchCamera","dispatchStream","useState","error","setError","reset","useCallback","getTracks","forEach","t","stop","useEffect","a","navigator","mediaDevices","enumerateDevices","camList","dev","kind","getCapabilities","push","deviceId","length","Error","getCameraList","selectedCamera","undefined","alert","getUserMedia","webkitGetUserMedia","mozGetUserMedia","msGetUserMedia","video","getCameraPermission","message","onChange","e","target","value","console","log","cam","i","key","defaultValue","indexOf","Display","monitor","useRef","current","srcObject","ref","autoPlay","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.33e009ba.chunk.js","sourcesContent":["import React, { useState, useEffect, useCallback, useReducer } from 'react';\n\nconst resList = [\n\t[640, 480, '480p - 4:3'],\n\t[1280, 720, '720p - 16:9'],\n\t[1920, 1080, '1080p - 16:9']\n];\n\nconst getConstraints = ({height, width}) => {\n\tconst filtredRes = resList.filter((res) => (\n\t\tres[0] >= width.min && res[0] <= width.max\n\t\t&& res[1] >= height.min && res[1] <= height.max\n\t));\n\treturn filtredRes.map(res => ({\n\t\tlabel: res[2],\n\t\twidth: { exact: res[0] },\n    height: { exact: res[1] }\n\t}))\n};\n\nfunction hasGetUserMedia() {\n  return !!(\n    (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) ||\n    navigator.webkitGetUserMedia ||\n    navigator.mozGetUserMedia ||\n    navigator.msGetUserMedia\n  );\n};\n\nconst cameraReducer = ({cameraList, selected}, {type, id, list, resolution}) => {\n\tswitch (type) {\n\t\tcase 'SET_LIST':\n\t\t\treturn {cameraList: list, selected: 0};\n\t\tcase 'SELECT':\n\t\t\treturn {cameraList: [...cameraList], selected: id};\n\t\tcase 'SELECT_RES':\n\t\t\tcameraList[selected].selectedRes = cameraList[selected].resolutions[resolution];\n\t\t\treturn {cameraList: [...cameraList], selected}\n\t\tdefault:\n\t\t\treturn {cameraList: [...cameraList], selected};\n\t}\n}\n\nconst streamReducer = ({stream, permitted}, {type, newstream}) => {\n\tswitch (type) {\n\t\tcase 'SET_STREAM':\n\t\t\treturn {stream: newstream, permitted: true}\n\t\tcase 'RESET_STREAM':\n\t\t\treturn {stream: null, permitted}\n\t\tdefault:\n\t\t\treturn {stream, permitted};\n\t}\n}\n\nconst Camera = ({children}) => {\n\tconst [{selected, cameraList}, dispatchCamera] = useReducer(cameraReducer, {cameraList: [], selected: null});\n\tconst [{stream, permitted}, dispatchStream] = useReducer(streamReducer, {stream: null, permitted: false});\n\tconst [error, setError] = useState(null);\n\t\n\tconst reset = useCallback(() => {\n\t\tsetError(null);\n\t\tif(stream)\n\t\t\tstream.getTracks().forEach(t => t.stop());\n\t}, [stream]);\n\n\tuseEffect(() => {\n\t\tconst getCameraList = async () => {\n\t\t\tif('mediaDevices' in navigator && 'enumerateDevices' in navigator.mediaDevices) {\n\t\t\t\ttry {\n\t\t\t\t\tconst list = await navigator.mediaDevices.enumerateDevices();\n\t\t\t\t\tlet camList = [];\n\t\t\t\t\tlist.forEach(dev => {\n\t\t\t\t\t\tif(dev.kind === 'videoinput'){\n\t\t\t\t\t\t\tlet resolutions = getConstraints(dev.getCapabilities())\n\t\t\t\t\t\t\tcamList.push({label: dev.label, deviceId: dev.deviceId, resolutions, selectedRes: resolutions[resolutions.length - 1]});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\tdispatchCamera({type: 'SET_LIST', list: camList});\n\t\t\t\t} catch (error) {\n\t\t\t\t\tsetError(new Error('Camera Error!'));\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tgetCameraList();\n\t\treturn reset;\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t}, [permitted]);\n\n\tuseEffect(() => {\n\t\t\n\t\tconst selectedCamera = (!!cameraList.length && selected > -1) ? cameraList[selected]:undefined;\n\t\talert(selectedCamera)\n\t\tif(!selectedCamera) return;\n\t\tconst getCameraPermission = async () => {\n\t\t\tif(hasGetUserMedia() && !!selectedCamera){\n\t\t\t\ttry {\n\t\t\t\t\tconst stream = await navigator.mediaDevices.getUserMedia({\n\t\t\t\t\t\tvideo: {\n\t\t\t\t\t\t\tdeviceId: {\n\t\t\t\t\t\t\t\texact: selectedCamera.deviceId\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\twidth: {\n\t\t\t\t\t\t\t\t...selectedCamera.selectedRes.width\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\theight: {\n\t\t\t\t\t\t\t\t...selectedCamera.selectedRes.height\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tdispatchStream({type: 'SET_STREAM', newstream: stream});\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn setError(new Error('Please allow us to use the camera.'))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn setError(new Error('No camera device was found!'));\n\t\t\t};\n\t\t};\n\t\tgetCameraPermission();\n\t\treturn reset;\n\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t}, [cameraList, selected]);\n\n\tif(!!error) \n\t\treturn (<span>{error.message}</span>)\n\treturn (\n\t\t<>\n\t\t\t{\n\t\t\t\t!!cameraList.length && selected > -1 &&\n\t\t\t\t<>\n\t\t\t\t\t<select onChange={(e) => {dispatchCamera({type: 'SELECT', id: e.target.value}); console.log(stream)}}>\n\t\t\t\t\t\t{cameraList.map((cam, i) => {\t\t\t\t\t\n\t\t\t\t\t\t\treturn <option key={cam.deviceId} value={i}>{cam.label}</option>\n\t\t\t\t\t\t})}\n\t\t\t\t\t</select>\n\t\t\t\t\t<select defaultValue={cameraList[selected].resolutions.indexOf(cameraList[selected].selectedRes)} onChange={(e) => {dispatchCamera({type: 'SELECT_RES', id: selected, resolution:e.target.value}); console.log(stream)}}>\n\t\t\t\t\t\t{cameraList[selected].resolutions.map((res, i) => {\t\t\t\t\t\n\t\t\t\t\t\t\treturn <option key={res.label} value={i}>{res.label}</option>\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t})}\n\t\t\t\t\t</select>\n\t\t\t\t</>\n\t\t\t}\n\t\t\t{children({stream})}\n\t\t</>\n\t);\n}\n\nexport default Camera;\n","import React, { useEffect, useRef } from 'react';\n\nconst Display = ({stream}) => {\n\tconst monitor = useRef(null);\n\tuseEffect(() => {\n\t\tif(!stream) return;\n\t\tmonitor.current.srcObject = stream;\n\t}, [stream]);\n\treturn (\n\t\t<div>\n\t\t\t<video ref={monitor} autoPlay></video>\n\t\t</div>\n\t);\n}\n\nexport default Display;\n","import React from 'react';\nimport './App.css';\nimport Camera from './fragments/Camera';\nimport Display from './fragments/Display';\n\nfunction App() {\n\n  return (\n\t\t<>\n\t\t\t<Camera>\n\t\t\t\t{({stream}) => (\n\t\t\t\t\t<Display stream={stream} />\n\t\t\t\t)}\n\t\t\t</Camera>\n\t\t</>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}